#!/usr/bin/env python3

# This script is inspired by isort: https://github.com/PyCQA/isort/blob/4ccbd1eddf564d2c9e79c59d59c1fc06a7e35f94/scripts/mkstdlibs.py.

import urllib.request
from html.parser import HTMLParser
from typing import List, Optional, Tuple

OUTPUT_PATH = "deptry/stdlibs/py{}.py"
STDLIB_MODULES_URL = "https://docs.python.org/{}/py-modindex.html"
PYTHON_VERSIONS = (("3", "7"), ("3", "8"), ("3", "9"), ("3", "10"), ("3", "11"))

# Modules that are in stdlib, but undocumented.
EXTRA_STDLIBS_MODULES = ("_ast", "ntpath", "posixpath", "sre", "sre_constants", "sre_compile", "sre_parse")

DOCSTRING_GENERATED_FILES = """
DO NOT EDIT THIS FILE MANUALLY.
It is generated from `scripts/generate_stdlibs.py` script and contains the stdlib modules for Python {}.
You can generate it again using `poetry run scripts/generate_stdlibs.py`.
"""


class PythonStdlibHTMLParser(HTMLParser):
    def __init__(self) -> None:
        super().__init__()
        self._is_in_code_tag = False
        self.modules: List[str] = []

    def handle_starttag(self, tag: str, attrs: List[Tuple[str, Optional[str]]]) -> None:
        if tag == "code":
            self._is_in_code_tag = True

    def handle_endtag(self, tag: str) -> None:
        if tag == "code":
            self._is_in_code_tag = False

    def handle_data(self, data: str) -> None:
        if self._is_in_code_tag:
            self.modules.append(data)


for python_version in PYTHON_VERSIONS:
    dotted_python_version = ".".join(python_version)

    with urllib.request.urlopen(STDLIB_MODULES_URL.format(dotted_python_version)) as response:
        html_content = response.read().decode()

    parser = PythonStdlibHTMLParser()
    parser.feed(html_content)

    modules = {module.split(".")[0] for module in parser.modules}.union(EXTRA_STDLIBS_MODULES)
    modules.remove("__main__")

    with open(OUTPUT_PATH.format("".join(python_version)), "w") as python_stdlib_file:
        python_stdlib_file.write(f'"""{DOCSTRING_GENERATED_FILES.format(dotted_python_version)}"""\n\n')
        python_stdlib_file.write("stdlib = {\n")

        for module in sorted(modules):
            python_stdlib_file.write(f'    "{module}",\n')
        python_stdlib_file.write("}\n")
